{"version":15,"variables":[{"key":"entityType","type":"code","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchAllEntityTypes() {\n  const entityTypes = new Set();\n  let nextPageKey = null;\n\n  try {\n    do {\n      const config = nextPageKey ? { nextPageKey } : { pageSize: 100 };\n\n      const response = await monitoredEntitiesClient.getEntityTypes(config);\n\n      response.types.forEach(entityType => {\n        entityTypes.add(entityType.type);\n      });\n\n      nextPageKey = response.nextPageKey;\n    } while (nextPageKey);\n\n    return Array.from(entityTypes);\n  } catch (error) {\n    console.error(\"Error fetching entity types:\", error);\n    return [];\n  }\n}","multiple":true,"defaultValue":["HOST","PROCESS_GROUP","SERVICE","APPLICATION"],"visible":true}],"tiles":{"7":{"type":"code","title":"Selected entityType Table","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\n// Fetch entities by type\nasync function fetchEntitiesByType(entityType) {\n  try {\n    const baseConfig = {\n      entitySelector: `type(\"${entityType}\")`,\n      pageSize: 500,\n      resolution: \"Inf\",\n      from: \"now-1h\",  // Time range is set to the last hour\n      fields: \"tags,managementZones,lastSeenTms,firstSeenTms\"\n    };\n\n    let entities = [];\n    let nextPageKey = null;\n\n    do {\n      const config = nextPageKey ? { nextPageKey } : baseConfig;\n      const response = await monitoredEntitiesClient.getEntities(config);\n      console.log(\"Fetched response for type\", entityType, \":\", response);\n      if (response.entities) {\n        entities = entities.concat(response.entities);\n      }\n      nextPageKey = response.nextPageKey;\n    } while (nextPageKey);\n\n    return entities;\n  } catch (error) {\n    console.error(`Error fetching entities of type ${entityType}:`, error);\n    return [];\n  }\n}\n\n// Fetch all entities by types\nasync function fetchEntities(entityTypes) {\n  try {\n    let allEntities = [];\n    for (const type of entityTypes) {\n      const entities = await fetchEntitiesByType(type);\n      allEntities = allEntities.concat(entities);\n    }\n\n    // Log the full payload for reference\n    console.log(\"Fetched Entities Payload:\", allEntities);\n\n    return allEntities;\n  } catch (error) {\n    console.error(\"Error fetching entities:\", error);\n    return [];\n  }\n}\n\n// Validate entities and create lists with issues\nasync function validateEntities(allEntities) {\n  const entitiesWithIssues = [];\n\n  allEntities.forEach(entity => {\n    const askidTag = entity.tags.find(tag => tag.key === \"Askid\");\n    let issue = null;\n\n    if (!askidTag) {\n      issue = 'Untagged';  // Entities are marked as 'untagged' if they don't have an 'Askid' tag or if the 'Askid' tag value is 'unknown'\n    }\n    else if(askidTag.value === \"UNKNOWN\"){\n      issue = 'Tagged_as_Unknown'\n      }\n    else {\n      const askidValue = askidTag.value;\n      const hasExpectedManagementZone = entity.managementZones.some(zone => {\n        const zoneParts = zone.name.split('.');\n        return zoneParts.length === 2 && zoneParts[1] === askidValue;\n      });\n\n      if (!hasExpectedManagementZone) {\n        issue = 'taggedWithoutManagementZone';\n      }\n    }\n\n    if (issue) {\n      entitiesWithIssues.push({\n        ...entity,\n        issue,\n      });\n    }\n  });\n\n  console.log(\"Entities with Issues:\", entitiesWithIssues.length);\n\n  return entitiesWithIssues;\n}\n\n// Main function\nexport default async function main() {\n  // Define the entity types you want to fetch\n  const entityTypes = $entityType;\n  \n  // Fetch and validate entities\n  const allEntities = await fetchEntities(entityTypes);\n  const entitiesWithIssues = await validateEntities(allEntities);\n\n  // Format the data for Dynatrace charting\n  const formattedData = entitiesWithIssues.map(entity => ({\n    \"Entity Name\": entity.displayName || \"N/A\",\n    \"Issue\": entity.issue,\n    \"Entity Type\": entity.type || \"N/A\",\n    \"Management Zones\": entity.managementZones ? entity.managementZones.map(zone => zone.name).join(', ') : \"N/A\",\n    \"Tags\": entity.tags ? entity.tags.map(tag => `${tag.key}:${tag.value}`).join(', ') : \"N/A\",\n    \"Entity ID\": entity.entityId || \"N/A\",\n    \"First Seen\": entity.firstSeenTms ? new Date(entity.firstSeenTms).toISOString() : \"N/A\",\n    \"Last Seen\": entity.lastSeenTms ? new Date(entity.lastSeenTms).toISOString() : \"N/A\"\n  }));\n\n  console.log(\"Formatted Data with Issues:\", formattedData);\n\n  return formattedData\n}","visualization":"table","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Tags\"]":718,"[\"Management Zones\"]":175.234375,"[\"Issue\"]":227.859375,"[\"Entity Type\"]":242.515625,"[\"Entity Name\"]":544.46875},"sortBy":{"columnId":"[\"Entity Name\"]","direction":"ascending"}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Entity Name"},"displayedFields":["Entity Name"],"colorMode":"color-palette","colorPalette":"categorical"},"histogram":{"dataMappings":[]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"9":{"type":"code","title":"NO MZ Count","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\n// Fetch entities by type\nasync function fetchEntitiesByType(entityType) {\n  try {\n    const baseConfig = {\n      entitySelector: `type(\"${entityType}\")`,\n      pageSize: 500,\n      resolution: \"Inf\",\n      from: \"now-1h\",  // Time range is set to the last hour\n      fields: \"tags,managementZones,lastSeenTms,firstSeenTms\"\n    };\n\n    let entities = [];\n    let nextPageKey = null;\n\n    do {\n      const config = nextPageKey ? { nextPageKey } : baseConfig;\n      const response = await monitoredEntitiesClient.getEntities(config);\n      //console.log(\"Fetched response for type\", entityType, \":\", response);\n      if (response.entities) {\n        entities = entities.concat(response.entities);\n      }\n      nextPageKey = response.nextPageKey;\n    } while (nextPageKey);\n\n    return entities;\n  } catch (error) {\n    console.error(`Error fetching entities of type ${entityType}:`, error);\n    return [];\n  }\n}\n\n// Fetch all entities by types\nasync function fetchEntities(entityTypes) {\n  try {\n    let allEntities = [];\n    for (const type of entityTypes) {\n      const entities = await fetchEntitiesByType(type);\n      allEntities = allEntities.concat(entities);\n    }\n\n    // Log the full payload for reference\n    //console.log(\"Fetched Entities Payload:\", allEntities);\n\n    return allEntities;\n  } catch (error) {\n    console.error(\"Error fetching entities:\", error);\n    return [];\n  }\n}\n\n// Validate entities and create lists with issues\nasync function validateEntities(allEntities) {\n  const entitiesWithIssues = {\"Untagged\": 0,\"Tagged_as_Unknown\": 0, \"Tagged_Without_MZ\": 0};\n\n  allEntities.forEach(entity => {\n    const askidTag = entity.tags.find(tag => tag.key === \"Askid\");\n    let issue = null;\n\n    if (!askidTag) {\n      issue = 'Untagged';  // Entities are marked as 'untagged' if they don't have an 'Askid' tag or if the 'Askid' tag value is 'unknown'\n    }\n    else if(askidTag.value === \"UNKNOWN\"){\n      issue = 'Tagged_as_Unknown'\n    }\n    else {\n      const askidValue = askidTag.value;\n      const hasExpectedManagementZone = entity.managementZones.some(zone => {\n        const zoneParts = zone.name.split('.');\n        return zoneParts.length === 2 && zoneParts[1] === askidValue;\n      });\n\n      if (!hasExpectedManagementZone) {\n        issue = 'Tagged_Without_MZ';\n      }\n    }\n\n    if (issue) {\n      entitiesWithIssues[issue] += 1;\n    }\n  });\n\n  console.log(\"Entities with Issues:\", entitiesWithIssues);\n\n  return entitiesWithIssues;\n}\n\n// Main function\nexport default async function main() {\n  // Define the entity types you want to fetch\n  const entityTypes = $entityType;\n  \n  // Fetch and validate entities\n  const allEntities = await fetchEntities(entityTypes);\n  const entitiesWithIssues = await validateEntities(allEntities);\n\n  // Log the count of entities with issues for each entity type\n  console.log(\"Count of Entities with Issues:\", entitiesWithIssues);\n  return entitiesWithIssues;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxisLabel":"Entity Name","valueAxisLabel":"Issue Count"},"hiddenLegendFields":[]},"singleValue":{"showLabel":true,"label":"No MZ","prefixIcon":"","recordField":"Tagged_Without_MZ","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Tags\"]":98}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Untagged"},"displayedFields":[null],"colorMode":"color-palette","colorPalette":"blue"},"histogram":{"dataMappings":[{"valueAxis":"Untagged","rangeAxis":""},{"valueAxis":"Tagged_as_Unknown","rangeAxis":""},{"valueAxis":"Tagged_Without_MZ","rangeAxis":""}]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"12":{"type":"code","title":"Count by EntityType","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\n// Fetch entities by type\nasync function fetchEntitiesByType(entityType) {\n  try {\n    const baseConfig = {\n      entitySelector: `type(\"${entityType}\")`,\n      pageSize: 500,\n      resolution: \"Inf\",\n      from: \"now-1h\",  // Time range is set to the last hour\n      fields: \"tags,managementZones,lastSeenTms,firstSeenTms\"\n    };\n\n    let entities = [];\n    let nextPageKey = null;\n\n    do {\n      const config = nextPageKey ? { nextPageKey } : baseConfig;\n      const response = await monitoredEntitiesClient.getEntities(config);\n      console.log(\"Fetched response for type\", entityType, \":\", response);\n      if (response.entities) {\n        entities = entities.concat(response.entities);\n      }\n      nextPageKey = response.nextPageKey;\n    } while (nextPageKey);\n\n    return entities;\n  } catch (error) {\n    console.error(`Error fetching entities of type ${entityType}:`, error);\n    return [];\n  }\n}\n\n// Fetch all entities by types\nasync function fetchEntities(entityTypes) {\n  try {\n    let allEntities = {};\n    for (const type of entityTypes) {\n      const entities = await fetchEntitiesByType(type);\n      allEntities[type] = entities;\n    }\n\n    // Log the full payload for reference\n    console.log(\"Fetched Entities Payload:\", allEntities);\n\n    return allEntities;\n  } catch (error) {\n    console.error(\"Error fetching entities:\", error);\n    return {};\n  }\n}\n\n// Validate entities and create lists with issues\nasync function validateEntities(allEntities) {\n  const issueCountsByType = {};\n\n  for (const [entityType, entities] of Object.entries(allEntities)) {\n    issueCountsByType[entityType] = {\n      Untagged: 0,\n      Tagged_as_Unknown: 0,\n      Tagged_Without_MZ: 0\n    };\n\n    entities.forEach(entity => {\n      const askidTag = entity.tags.find(tag => tag.key === \"Askid\");\n\n      if (!askidTag) {\n        issueCountsByType[entityType].Untagged++;\n      }\n      else if(askidTag.value === \"UNKNOWN\"){\n        issueCountsByType[entityType].Tagged_as_Unknown++;\n      }\n      else {\n        const askidValue = askidTag.value;\n        const hasExpectedManagementZone = entity.managementZones.some(zone => {\n          const zoneParts = zone.name.split('.');\n          return zoneParts.length === 2 && zoneParts[1] === askidValue;\n        });\n\n        if (!hasExpectedManagementZone) {\n          issueCountsByType[entityType].Tagged_Without_MZ++;\n        }\n      }\n    });\n  }\n\n  console.log(\"Issue Counts by Entity Type:\", issueCountsByType);\n\n  return issueCountsByType;\n}\n\n// Format the result for output\nfunction formatForOutput(issueCountsByType) {\n  const result = [];\n  for (const [entityType, counts] of Object.entries(issueCountsByType)) {\n    result.push({\n      entityType,\n      Untagged: counts.Untagged,\n      Tagged_as_Unknown: counts.Tagged_as_Unknown,\n      tagged_No_MZ: counts.Tagged_Without_MZ\n    });\n  }\n  return result;\n}\n\n// Main function\nexport default async function main() {\n  // Define the entity types you want to fetch\n  const entityTypes = $entityType;\n  \n  // Fetch and validate entities\n  const allEntities = await fetchEntities(entityTypes);\n  const issueCountsByType = await validateEntities(allEntities);\n\n  // Format the result for output\n  const formattedData = formatForOutput(issueCountsByType);\n\n  console.log(\"Formatted Data with Issue Counts by Entity Type:\", formattedData);\n\n  return formattedData;\n}","visualization":"table","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxis":"entityType","valueAxis":"Untagged","categoryAxisLabel":"entityType","valueAxisLabel":"Untagged"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Tags\"]":98,"[\"Tagged_as_Unknown\"]":195},"sortBy":{"columnId":"[\"Tagged_as_Unknown\"]","direction":"descending"}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"entityType"},"displayedFields":["entityType"],"colorMode":"color-palette","colorPalette":"categorical"},"histogram":{"dataMappings":[{"valueAxis":"Untagged","rangeAxis":""},{"valueAxis":"Tagged_as_Unknown","rangeAxis":""},{"valueAxis":"tagged_No_MZ","rangeAxis":""}]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"13":{"type":"code","title":"Untagged","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\n// Fetch entities by type\nasync function fetchEntitiesByType(entityType) {\n  try {\n    const baseConfig = {\n      entitySelector: `type(\"${entityType}\")`,\n      pageSize: 500,\n      resolution: \"Inf\",\n      from: \"now-1h\",  // Time range is set to the last hour\n      fields: \"tags,managementZones,lastSeenTms,firstSeenTms\"\n    };\n\n    let entities = [];\n    let nextPageKey = null;\n\n    do {\n      const config = nextPageKey ? { nextPageKey } : baseConfig;\n      const response = await monitoredEntitiesClient.getEntities(config);\n      //console.log(\"Fetched response for type\", entityType, \":\", response);\n      if (response.entities) {\n        entities = entities.concat(response.entities);\n      }\n      nextPageKey = response.nextPageKey;\n    } while (nextPageKey);\n\n    return entities;\n  } catch (error) {\n    console.error(`Error fetching entities of type ${entityType}:`, error);\n    return [];\n  }\n}\n\n// Fetch all entities by types\nasync function fetchEntities(entityTypes) {\n  try {\n    let allEntities = [];\n    for (const type of entityTypes) {\n      const entities = await fetchEntitiesByType(type);\n      allEntities = allEntities.concat(entities);\n    }\n\n    // Log the full payload for reference\n    //console.log(\"Fetched Entities Payload:\", allEntities);\n\n    return allEntities;\n  } catch (error) {\n    console.error(\"Error fetching entities:\", error);\n    return [];\n  }\n}\n\n// Validate entities and create lists with issues\nasync function validateEntities(allEntities) {\n  const entitiesWithIssues = {\"Untagged\": 0,\"Tagged_as_Unknown\": 0, \"Tagged_Without_MZ\": 0};\n\n  allEntities.forEach(entity => {\n    const askidTag = entity.tags.find(tag => tag.key === \"Askid\");\n    let issue = null;\n\n    if (!askidTag) {\n      issue = 'Untagged';  // Entities are marked as 'untagged' if they don't have an 'Askid' tag or if the 'Askid' tag value is 'unknown'\n    }\n    else if(askidTag.value === \"UNKNOWN\"){\n      issue = 'Tagged_as_Unknown'\n    }\n    else {\n      const askidValue = askidTag.value;\n      const hasExpectedManagementZone = entity.managementZones.some(zone => {\n        const zoneParts = zone.name.split('.');\n        return zoneParts.length === 2 && zoneParts[1] === askidValue;\n      });\n\n      if (!hasExpectedManagementZone) {\n        issue = 'Tagged_Without_MZ';\n      }\n    }\n\n    if (issue) {\n      entitiesWithIssues[issue] += 1;\n    }\n  });\n\n  console.log(\"Entities with Issues:\", entitiesWithIssues);\n\n  return entitiesWithIssues;\n}\n\n// Main function\nexport default async function main() {\n  // Define the entity types you want to fetch\n  const entityTypes = $entityType;\n  \n  // Fetch and validate entities\n  const allEntities = await fetchEntities(entityTypes);\n  const entitiesWithIssues = await validateEntities(allEntities);\n\n  // Log the count of entities with issues for each entity type\n  console.log(\"Count of Entities with Issues:\", entitiesWithIssues);\n  return entitiesWithIssues;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxisLabel":"Entity Name","valueAxisLabel":"Issue Count"},"hiddenLegendFields":[]},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","recordField":"Untagged","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Tags\"]":98}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Untagged"},"displayedFields":[null],"colorMode":"color-palette","colorPalette":"blue"},"histogram":{"dataMappings":[{"valueAxis":"Untagged","rangeAxis":""},{"valueAxis":"Tagged_as_Unknown","rangeAxis":""},{"valueAxis":"Tagged_Without_MZ","rangeAxis":""}]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"14":{"type":"code","title":"Tagged as UNKNOWN","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\n// Fetch entities by typeUNn\nasync function fetchEntitiesByType(entityType) {\n  try {\n    const baseConfig = {\n      entitySelector: `type(\"${entityType}\")`,\n      pageSize: 500,\n      resolution: \"Inf\",\n      from: \"now-1h\",  // Time range is set to the last hour\n      fields: \"tags,managementZones,lastSeenTms,firstSeenTms\"\n    };\n\n    let entities = [];\n    let nextPageKey = null;\n\n    do {\n      const config = nextPageKey ? { nextPageKey } : baseConfig;\n      const response = await monitoredEntitiesClient.getEntities(config);\n      //console.log(\"Fetched response for type\", entityType, \":\", response);\n      if (response.entities) {\n        entities = entities.concat(response.entities);\n      }\n      nextPageKey = response.nextPageKey;\n    } while (nextPageKey);\n\n    return entities;\n  } catch (error) {\n    console.error(`Error fetching entities of type ${entityType}:`, error);\n    return [];\n  }\n}\n\n// Fetch all entities by types\nasync function fetchEntities(entityTypes) {\n  try {\n    let allEntities = [];\n    for (const type of entityTypes) {\n      const entities = await fetchEntitiesByType(type);\n      allEntities = allEntities.concat(entities);\n    }\n\n    // Log the full payload for reference\n    //console.log(\"Fetched Entities Payload:\", allEntities);\n\n    return allEntities;\n  } catch (error) {\n    console.error(\"Error fetching entities:\", error);\n    return [];\n  }\n}\n\n// Validate entities and create lists with issues\nasync function validateEntities(allEntities) {\n  const entitiesWithIssues = {\"Untagged\": 0,\"Tagged_as_Unknown\": 0, \"Tagged_Without_MZ\": 0};\n\n  allEntities.forEach(entity => {\n    const askidTag = entity.tags.find(tag => tag.key === \"Askid\");\n    let issue = null;\n\n    if (!askidTag) {\n      issue = 'Untagged';  // Entities are marked as 'untagged' if they don't have an 'Askid' tag or if the 'Askid' tag value is 'unknown'\n    }\n    else if(askidTag.value === \"UNKNOWN\"){\n      issue = 'Tagged_as_Unknown'\n    }\n    else {\n      const askidValue = askidTag.value;\n      const hasExpectedManagementZone = entity.managementZones.some(zone => {\n        const zoneParts = zone.name.split('.');\n        return zoneParts.length === 2 && zoneParts[1] === askidValue;\n      });\n\n      if (!hasExpectedManagementZone) {\n        issue = 'Tagged_Without_MZ';\n      }\n    }\n\n    if (issue) {\n      entitiesWithIssues[issue] += 1;\n    }\n  });\n\n  console.log(\"Entities with Issues:\", entitiesWithIssues);\n\n  return entitiesWithIssues;\n}\n\n// Main function\nexport default async function main() {\n  // Define the entity types you want to fetch\n  const entityTypes = $entityType;\n  \n  // Fetch and validate entities\n  const allEntities = await fetchEntities(entityTypes);\n  const entitiesWithIssues = await validateEntities(allEntities);\n\n  // Log the count of entities with issues for each entity type\n  console.log(\"Count of Entities with Issues:\", entitiesWithIssues);\n  return entitiesWithIssues;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxisLabel":"Entity Name","valueAxisLabel":"Issue Count"},"hiddenLegendFields":[]},"singleValue":{"showLabel":true,"label":"Unknown","prefixIcon":"","recordField":"Tagged_as_Unknown","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Tags\"]":98}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Untagged"},"displayedFields":[null],"colorMode":"color-palette","colorPalette":"blue"},"histogram":{"dataMappings":[{"valueAxis":"Untagged","rangeAxis":""},{"valueAxis":"Tagged_as_Unknown","rangeAxis":""},{"valueAxis":"Tagged_Without_MZ","rangeAxis":""}]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"15":{"type":"markdown","title":"","content":"## Links\n\n- [Host](https://dfr17824.apps.dynatrace.com/ui/apps/dynatrace.classic.hosts/#newhosts)\n- [Technologies & Processes](https://dfr17824.apps.dynatrace.com/ui/apps/dynatrace.classic.technologies)\n- [Services](https://dfr17824.apps.dynatrace.com/ui/apps/dynatrace.classic.services/ui/services)\n- [Kubernetes Classic](https://dfr17824.apps.dynatrace.com/ui/apps/dynatrace.classic.kubernetes/ui/entity/list/KUBERNETES_CLUSTER)\n- [Kubernetes](https://dfr17824.apps.dynatrace.com/ui/apps/dynatrace.kubernetes/)"}},"layouts":{"7":{"x":0,"y":4,"w":24,"h":9},"9":{"x":8,"y":0,"w":4,"h":4},"12":{"x":12,"y":0,"w":8,"h":4},"13":{"x":0,"y":0,"w":4,"h":4},"14":{"x":4,"y":0,"w":4,"h":4},"15":{"x":20,"y":0,"w":4,"h":4}},"importedWithCode":false,"settings":{"defaultTimeframe":{"value":{"from":"now()-1h","to":"now()"},"enabled":true}}}